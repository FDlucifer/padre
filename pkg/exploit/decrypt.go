package exploit

import "fmt"

func (p *Padre) decrypt(ciphertext []byte, blockLen int, byteStreamer func(byte)) ([]byte, error) {
	// blockLen := *config.blockLen

	// // check for initial input
	// if encodedCipher == "" {
	// 	return nil, fmt.Errorf("empty input cipher")
	// }

	// // decode into bytes
	// cipher, err := config.encoder.DecodeString(encodedCipher)
	// if err != nil {
	// 	return nil, err
	// }

	// check length of ciphertext against block length
	if len(ciphertext)%blockLen != 0 {
		return nil, fmt.Errorf("Ciphertext length is not compatible with block length (%d %% %d != 0)", len(ciphertext), blockLen)
	}

	// // confirm validity of provided cipher
	// printAction("Confirming input cipher is valid...")
	// pe, err := isPaddingErrorChunk(cipher)
	// if err != nil {
	// 	return nil, err
	// }
	// if pe {
	// 	return nil, fmt.Errorf("Input cipher produced padding error. You must provide a valid cipher to decrypt")
	// }

	// count blocks
	blockCount := len(ciphertext) / blockLen

	// derive length of plaintext
	// NOTE: first block considered to be IV
	plainLen := len(ciphertext) - blockLen
	plainText := make([]byte, plainLen)

	// // initialize hacky bar
	// currentStatus.openBar(plainLen)
	// defer currentStatus.closeBar()

	// decrypt block by block moving backwards, except first (IV)
	for blockNum := blockCount; blockNum >= 2; blockNum-- {
		// mark indexes
		x := (blockNum - 2) * blockLen
		y := (blockNum - 1) * blockLen
		z := blockNum * blockLen

		// get cipher block and corresponding IV from ciphertext
		IV, block := ciphertext[x:y], ciphertext[y:z]

		// derive the nulling IV for the block
		nullingIV, err := p.breakCipher(block, createXORingFetcher(IV))
		if err != nil {
			return nil, fmt.Errorf("error occurred while decrypting block %d: %w", blockNum, err)
		}

		// derive plaintext block
		copy(plainText[x:y], xorSlices(nullingIV, IV))
	}

	return plainText, nil
}
