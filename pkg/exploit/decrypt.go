func decrypt(encodedCipher string) ([]byte, error) {
	blockLen := *config.blockLen

	// check for initial input
	if encodedCipher == "" {
		return nil, fmt.Errorf("empty input cipher")
	}

	// decode into bytes
	cipher, err := config.encoder.DecodeString(encodedCipher)
	if err != nil {
		return nil, err
	}

	// check length of cipher against block length
	if len(cipher)%blockLen != 0 {
		return nil, fmt.Errorf("Cipher length is not compatible with block length (%d %% %d != 0)", len(cipher), blockLen)
	}

	// confirm validity of provided cipher
	printAction("Confirming input cipher is valid...")
	pe, err := isPaddingErrorChunk(cipher)
	if err != nil {
		return nil, err
	}
	if pe {
		return nil, fmt.Errorf("Input cipher produced padding error. You must provide a valid cipher to decrypt")
	}

	// count blocks
	blockCount := len(cipher) / blockLen

	// derive length of plaintext
	// NOTE: first block considered to be IV
	plainLen := (blockCount - 1) * blockLen
	plainText := make([]byte, plainLen)

	// initialize hacky bar
	currentStatus.openBar(plainLen)
	defer currentStatus.closeBar()

	// decrypt block by block moving backwards, except first (IV)
	for blockNum := blockCount; blockNum >= 2; blockNum-- {
		// mark indexes
		x := (blockNum - 2) * blockLen
		y := (blockNum - 1) * blockLen
		z := blockNum * blockLen

		// get cipher block and corresponding IV from ciphertext
		IV, block := cipher[x:y], cipher[y:z]

		// derive the nulling IV
		nullingIV, err := breakCipher(block, createXORingFetcher(IV))
		if err != nil {
			return nil, fmt.Errorf("error occurred while decrypting block %d: %w", blockNum, err)
		}

		// derive plaintext block
		copy(plainText[x:y], xorSlices(nullingIV, IV))
	}

	return plainText, nil
}