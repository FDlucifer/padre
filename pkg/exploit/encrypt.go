func encrypt(plainText string) ([]byte, error) {
	blockLen := *config.blockLen

	// pad
	padding := blockLen - len(plainText)%blockLen
	plainText += strings.Repeat(string(padding), padding)

	blockCount := len(plainText) / blockLen

	// initialize a slice that will contain our cipherText (blockCount + 1 for IV)
	cipher := append(make([]byte, blockLen*blockCount), randomBlock(blockLen)...)

	// initialize status bar
	currentStatus.openBar(len(cipher))
	defer currentStatus.closeBar()

	// the last block is already known, so we report in to status
	currentStatus.fetchOutputBytes(cipher[blockLen*blockCount:])

	/* Start with the last block and move towards the 1st block.
	Each block is used successively as a IV and then as a cipherText in the next iteration */
	for blockNum := blockCount; blockNum >= 1; blockNum-- {
		// mark indexes
		x := (blockNum - 1) * blockLen
		y := blockNum * blockLen
		z := (blockNum + 1) * blockLen

		plainBlock := []byte(plainText)[x:y]

		// get nulling IV
		nullingIV, err := breakCipher(cipher[y:z], createXORingFetcher(plainBlock))
		if err != nil {
			return nil, fmt.Errorf("error occurred while encrypting block %d: %w", blockNum, err)
		}

		// reveal the cipher
		copy(cipher[x:y], xorSlices(plainBlock, nullingIV))
	}
	return cipher, nil
}