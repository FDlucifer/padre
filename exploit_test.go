package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
)

var (
	vulnHost = "localhost"
	vulnPort = 5000
)

type Resp struct {
	statusCode int
	body       []byte
}

// call URL at remote server
func callRoute(method, route string, params map[string]string) (*Resp, error) {
	// create request
	req, err := http.NewRequest(method, fmt.Sprintf("http://%s:%d%s", vulnHost, vulnPort, route), nil)
	if err != nil {
		return nil, err
	}

	// build params
	data := url.Values{}
	for key, val := range params {
		data.Add(key, val)
	}

	// attach HTTP params
	switch method {
	case "GET":
		req.URL.RawQuery = data.Encode()
	case "POST":
		req.Body = ioutil.NopCloser(strings.NewReader(data.Encode()))
	default:
		log.Fatalf("Unsupported method %s", method)
	}

	// send request
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	// read body
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	// return
	return &Resp{resp.StatusCode, body}, nil
}

// check remote server healt
func checkHealth() error {
	resp, err := callRoute("GET", "/health", nil)
	if err != nil {
		return err
	}

	if resp.statusCode != 200 {
		return fmt.Errorf("Health status code was not 200")
	}

	return nil
}

func callEncrypt(plaintext string) (*Resp, error) {
	resp, err := callRoute("GET", "/encrypt", map[string]string{"plain": plaintext})
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func callDecrypt(cipher string) (*Resp, error) {
	resp, err := callRoute("GET", "/decrypt", map[string]string{"cipher": cipher})
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func init() {
	url := fmt.Sprintf("http://%s:%d/decrypt?cipher=$", vulnHost, vulnPort)
	errorPattern := "IncorrectPadding"
	blockLen := 16
	emptyStr := ""
	parallel := 50
	encrypt := false

	config.URL = &url
	config.blockLen = &blockLen
	config.encoder = createB64encDec("")
	config.paddingErrorPattern = &errorPattern
	config.POSTdata = &emptyStr
	config.proxyURL = &emptyStr
	config.parallel = &parallel
	config.encrypt = &encrypt
	config.termWidth = terminalWidth()

	outputStream = ioutil.Discard

	initHTTP()

	err := detectOrConfirmPaddingOracle(*config.blockLen)
	if err != nil {
		log.Fatal(err)
	}
}

func Test_decrypt(t *testing.T) {
	// type args struct {
	// 	encodedCipher string
	// }
	// tests := []struct {
	// 	name    string
	// 	args    args
	// 	want    []byte
	// 	wantErr bool
	// }{
	// 	// TODO: Add test cases.
	// }
	// for _, tt := range tests {
	// 	t.Run(tt.name, func(t *testing.T) {
	// 		got, err := decrypt(tt.args.encodedCipher)
	// 		if (err != nil) != tt.wantErr {
	// 			t.Errorf("decrypt() error = %v, wantErr %v", err, tt.wantErr)
	// 			return
	// 		}
	// 		if !reflect.DeepEqual(got, tt.want) {
	// 			t.Errorf("decrypt() = %v, want %v", got, tt.want)
	// 		}
	// 	})
	// }

	// test plaintext
	plaintext := "0123456789abc" + string(3) + string(2)

	// encrypt test data
	resp, err := callEncrypt(plaintext)
	assert.Equal(t, resp.statusCode, 200)
	assert.NoError(t, err)

	validCipher := resp.body

	// try to break the cipher
	createNewStatus()
	decryptedChiper, err := decrypt(string(validCipher))
	assert.NoError(t, err)
	fmt.Println(asciiEncoder{}.EncodeToString(decryptedChiper))
	fmt.Println(asciiEncoder{}.EncodeToString(pad(plaintext)))
	assert.Equal(t, decryptedChiper, pad(plaintext))

	closeCurrentStatus()
}

func Test_encrypt(t *testing.T) {
	*config.encrypt = true

	// test plaintext
	plaintext := "01234567890abcd"

	// encrypt using padding oracle
	createNewStatus()
	exploitedCipher, err := encrypt(plaintext)
	assert.NoError(t, err)
	closeCurrentStatus()

	// encode
	encodedExploitedCipher := config.encoder.EncodeToString(exploitedCipher)

	// decrypt using legit route
	resp, err := callDecrypt(encodedExploitedCipher)
	assert.Equal(t, resp.statusCode, 200)
	assert.NoError(t, err)

	// compare the two
	assert.Equal(t, string(resp.body), plaintext)

}

func pad(in string) []byte {
	inB := []byte(in)
	padding := *config.blockLen - len(inB)%*config.blockLen
	inB = append(inB, bytes.Repeat([]byte{byte(padding)}, padding)...)
	return inB
}

// func TestMain(m *testing.M) {
// 	ctx := context.Background()
// 	req := testcontainers.ContainerRequest{
// 		FromDockerfile: testcontainers.FromDockerfile{
// 			Context: "test_server",
// 		},
// 		Name: vulnHost,
// 		WaitingFor: &wait.HTTPStrategy{
// 			Path:              "/health",
// 			Port:              "5000/tcp",
// 			StatusCodeMatcher: func(status int) bool { return status == 200 },
// 		},
// 		AutoRemove:   true,
// 		ExposedPorts: []string{"5000/tcp"},
// 	}

// 	vulnC, err := testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{
// 		ContainerRequest: req,
// 		Started:          true,
// 	})
// 	if err != nil {
// 		log.Fatal(err)
// 	}
// 	defer vulnC.Terminate(ctx)

// 	vulnHost, err = vulnC.Host(ctx)
// 	if err != nil {
// 		log.Fatal(err)
// 	}

// 	port, err := vulnC.MappedPort(ctx, "5000/tcp")
// 	if err != nil {
// 		log.Fatal(err)
// 	}
// 	vulnPort = port.Port()

// 	// check healt
// 	err = checkHealth()
// 	if err != nil {
// 		log.Fatal(err)
// 	}

// 	// run tests
// 	retcode := m.Run()

// 	os.Exit(retcode)
// }
